# [자료구조] Tree

## **트리란?**
- 노드들이 나무 가지처럼 연결된 **비선형(non-linear)**, **계층적** 자료 구조
- 한 노드가 여러 노드를 가르킬 수 있는 비선형적 자료구조
- List, Stack, Queue는 이전 데이터와 다음 데이터간의 순서가 존재
- But 트리 구조 특성상 순서는 그렇게 중요하지 않음
- **그래프의 일종**이며 데이터 구조의 **상하 개념 계층의 구조적 속성을 표현**한다는 특징이 있음

### **용어**
![alt text](../img/java_tree.png)

- **Node**: 트리 구조에서 각 **구성요소**(A ~ J)
- **Root Node**: 트리 시작 노드, 부모가 없는 **최상위 노드(A)
- **Edge**: 노드와 노드를 연결하는 선
- **Path**: 특정 노드에서 노드까지의 **경로**(순서)
- **Treminal Node(Leaf Node)**: **자식 노드가 존재하지 않는** 노드(H,I,J,F,G)
- **Sub-Tree**: 전체 큰 트리 구조 안의 작은 트리 구조<br>
    - 트리의 **재귀**적인 특성을 보여줌<br>
- **Depth**: **Root Node**로부터 얼마나 떨어져 있는 지를 뜻하는 단위<br>
    - 루트 노드의 바로 아래 노드의 depth = 1<br>
- **Level**: **같은 depth**를 가지는 노드들을 한 레벨로 나타내는 단위<br>
    - Root Node 기준, 이 위치를 level 0으로 잡음<br>
    - 루트 노드에서 어떤 노드까지의 **간선 수**<br>
- **Height**: 트리에서 가장 **최고 레벨**, 가장 깊은 층
- **Order**: 부모 노드에서 가질 수 있는 **최대 자식 수**<br>
    - e.g. If order 4 -> 부모 노드는 최대 3명의 자식 노드를 가질 수 있음<br>
- **Sibling관계**: 같은 부모를 가진 노드
- **degree**: 자식 수를 나타낸 차수<br>
    - Node D는 H, I의 부모 노드이며, degree = 2<br>

![alt text](../img/java_treee_exam.png)

## 사용 예시
1. **계층적인 데이터 저장**
    - 데이터를 계층 구조로 저장 -> 파일이나 폴더와 같이 계층 구조를 갖는 곳에 사용<br>
2. **효율적인 검색 속도**
    - 효율적인 삽입, 삭제, 검색을 위해 사용<br>
3. **Heap(힙)**
    - **[Heap 정렬](Queue_Heap.md)**은 우선순위 큐에서 사용하는 정렬<br>
4. **DB 인덱싱**
    - DB 인덱싱을 구현하는 데 사용<br>
    - e.g. B-Tree, B+Tree, AVL-Tree<br>
5. **[Trie 자료 구조](Trie.md)**
    - Dictionary를 저장하는데 사용되는 특별한 종류의 트리<br>

## 트리 종류

### **Skew Tree(편향 트리 = 경사 트리)**
- 모든 노드들이 자식 노드를 **하나씩만** 가진 트리
- 아래 그림에서는 왼쪽 자식만 존재 -> left skew tree

![alt text](../img/java_left_skew_tree.png)

### **Binary Search Tree(BST; 이진탐색트리)**
- <U>순서화된 이진 트리</U>
- **규칙**
    ```
    노드의 왼쪽 자식 값 < 부모 값
    노드의 오른쪽 자식 값 > 부모 값
    ```
### **m원 탐색 트리(m-way Search Tree)**
- 최대 m 개의 서브 트리를 갖는 탐색 트리
- <U>이진 탐색트리의 확장 형태</U> -> 높이를 줄이기 위해 사용

### **B-Tree(Balanced Tree, 균형 트리)**
- m원 탐색 트리에서 높이 균형을 유지하는 트리
- **height-Balanced m-way tree**라고도 함


### **Binary Tree(이진 트리)**
#### **특징**
- 각 노드가 최대 2개(0 - 2)의 자식 노드를 가진 트리
- 자식 노드에는 왼쪽 자식 노드와 오른쪽 자식 노드가 있으며, 이 둘은 엄연히 다른 노드
- 최대 2개라는 것 = **없을 수도(0)**있고 **1개만** 있을 수도 있다

![alt text](../img/java_B_Tree_1.png)

#### **이진트리 유형**
1. **정 이진 트리(full binary tree) or 엄격한(Strict) 이진트리**
: **모든 노드가** <U>2개의 자식</U>을 가지는 트리(즉, 자식 노드가 1개인 노드가 아예 없어야 만족)
    ```
    왼쪽 그림은 자식 노드가 하나인 노드가 존재 -> 정 이진 트리 X
    오른쪽은 자식 노드가 하나인 노드 존재 X -> 정 이진 트리
    ```
![alt text](../img/java_B_Tree_2.png)

2. **Perfect Binary Tree(포화 이진 트리)**
: 모든 노드가 2개의 자식을 가지고 **leaf 노드가 모두 같은 레벨인 트리**
- **높이가 h**일 때,
    - **노드 갯수** = 2^(k+1) - 1개를 가짐<br>
    - **Leaf Node 갯수** = 2^h개<br>

![alt text](../img/java_B_Tree_3.png)
![alt text](../img/java_B_Tree_4.png)

3. **Complete Binary Tree(완전 이진 트리)**
: 아래 두 조건을 모두 만족하는 트리
    - 마지막 레벨을 제외하고 모든 노드가 채워진 트리 구조<br>
    - 노드는 왼쪽에서 오른쪽으로 채워져야 함<br>
- 아래 두 개는 모두 완전 이진 트리
- If 왼쪽 그림에서 Level 1의 오른쪽 노드의 자식 노드가 오른쪽이라면? 완전 이진 트리 X

![alt text](../img/java_B_Tree_5.png)

```
포화 이진 트리는 완전 이진트리의 조건을 모두 만족
-> 포화 이진 트리는 완전 이진 트리에 속함
명제의 역은 무조건 성립하는 것이 아님
```
#### **1차원 배열로 표현하는 이진 트리**
: 트리는 **선형 구조**인 **1차원 배열**로 표현 가능

![alt text](../img/java_B_Tree_6.png)

- 왼쪽 트리는 **Level 순**, 그 이후엔 **왼쪽에서 오른쪽 순서**로 각 노드에 index를 붙여 표현 가능
- So, **완전 이진 트리**는 위의 그림과 같이 <U>배열을 빈틈없이 모두 채울 수 있음</U>

[추가 이해를 위한 그림]
![alt text](../img/java_B_Tree_7.png)

- 완전 이진 트리는 왼쪽 -> 오른쪽으로 채워진다.
- <U>경사 이진 트리</U>는 배열에 빈 공간이 발생 -> 불필요한 공간이 낭비될 수 있고 배열 크기를 넘어가는 노드를 추가할 수 없다는 점이 단점

[중간이 비어있는 경우]
![alt text](../img/java_B_Tree_8.png)

- 중간이 비어 있는 트리의 경우, 배열 사이에 null값이 들어간 구조로 나타남
- 배열을 사용할 때, **0번 index는 비우고 1번 index부터 Root Node를 채움** -> 이유: 탐색을 쉽게 하기 위함

#### **이진트리 속성으로 정해지는 배열의 인덱스**
|           루트 노드 인덱스가 1        |          루트 노드 인덱스가 0           |
|:------------------------------------:|:-------------------------------------:|
|![alt text](../img/java_B_Tree_9.png) | ![alt text](../img/java_B_Tree_10.png)|

- 중간이 비어있는 트리 구조에서 6의 index 찾기
    - 6 = 노드 3의 왼쪽 자식 노드<br>
    - 표의 3번째 식 사용 -> 3 * 2 = 6
    - So, 6의 index = 6

- 이진 트리를 구현함에 있어 **노드를 사용** -> left 노드와 right 노드를 통해 구현

```java
class Node{
    int data;
    Node left;
    Node right;
}
```
![alt text](../img/java_B_Tree_11.png)

- **연결 리스트**를 사용하면 배열보다 access 속도는 느림
- But, 삽입, 삭제가 쉽고, 노드를 포인터로 연결하는 개념이기에 노드 수 제한 X

#### **이진 트리 응용**
1. **Heap**
2. **Binary Search Tree**
3. **B-Tree**: 이진 트리의 응용으로 DB나 파일 시스템에 사용되는 중요한 구조
4. **AVL Tree**: Adelson-Velsky and Landis에서 따옴
5. **Expression Tree**
6. **Huffman Coding Tree**
7. **PQ(우선순위큐)**

#### **이진 트리 기본 연산**
- 트리도 자료 구조 So, 다른 구조들과 동일하게 아래와 같은 연산 가능
    - 트리에 데이터 삽입<br>
    - 데이터 삭제<br>
    - 데이터 검색<br>
    - 트리 탐색<br>

#### **트리 순회**
: 트리 구조에서 각 노드를 한 번씩 방문하는 과정

